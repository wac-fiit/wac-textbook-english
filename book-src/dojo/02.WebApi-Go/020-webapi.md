# Generating the Web API Service Skeleton Code

---

>info:>
Template for the pre-created container ([Details here](../99.Problems-Resolutions/01.development-containers.md)):
`registry-1.docker.io/milung/wac-api-020`

---

Similar to generating client code in the previous exercise, when generating the skeleton code for the API service, we will use OpenAPI tools. The difference in this case lies mainly in the fact that, for the server, the generator cannot determine the required application logic. Therefore, it generates only a basic skeleton, and we need to implement the actual functionality ourselves.

To generate the code, we will use the [go-gin-server](https://openapi-generator.tech/docs/generators/go-gin-server) generator. Although the functionality generated by this generator would be sufficient for the exercise, we will show how to modify the generator's templates to generate abstract types. This way, we can achieve repeated code generation in case of changes to the API specification without the need for manual rewriting of existing code.

1. Create a file `${WAC_ROOT}/ambulance-webapi/scripts/run.ps1` with the following content:

```ps
param (
    $command
)

if (-not $command)  {
    $command = "start"
}

$ProjectRoot = "${PSScriptRoot}/.."

$env:AMBULANCE_API_ENVIRONMENT="Development"
$env:AMBULANCE_API_PORT="8080"  

switch ($command) {
    "start" {
        go run ${ProjectRoot}/cmd/ambulance-api-service
    }
    "openapi" {
        docker run --rm -ti -v ${ProjectRoot}:/local openapitools/openapi-generator-cli generate -c /local/scripts/generator-cfg.yaml 
    }
    default {
        throw "Unknown command: $command"
    }
}
```

In this project, we won't be using `openapi-generator-cli` through the npm package. Instead, we will directly use its implementation provided as a software image. We will further extend the `run.ps1` script for the purpose of automating frequently executed commands during development. Now, create a file `${WAC_ROOT}/ambulance-webapi/scripts/generator-cfg.yaml` with the following content:

```yaml
generatorName: go-gin-server
outputDir: /local
inputSpec: /local/api/ambulance-wl.openapi.yaml
enablePostProcessFile: true
additionalProperties:
  apiPath: internal/ambulance_wl
  packageName: ambulance_wl
```

Create a file `${WAC_ROOT}/ambulance-webapi/.openapi-generator-ignore` with the following content:

```text
main.go
go.mod
Dockerfile
README.md
api/openapi.yaml
```

By using this specification, we prevent the generation of files that we do not want to generate.

2. Save the files, and in the directory `${WAC_ROOT}/ambulance-webapi`, execute the command:


```ps
./scripts/run.ps1 openapi
```

After its completion, in the directory `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl`, files will appear containing handler functions for processing requests coming to the API. For example, in the file `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl/api_ambulance_waiting_list.go`, you will find functions such as

```go
...
// CreateWaitingListEntry - Saves new entry into waiting list
func CreateWaitingListEntry(c *gin.Context) {
c.JSON(http.StatusOK, gin.H{})
}
...
```

>info:> The directory named `internal` prevents access to the definitions of types contained in it from other modules. A package whose implementation is in a directory with any parent directory named internal provides its exported types only within the module in which it is implemented.

3. The functions mentioned above could be modified and then used in the file `${WAC_ROOT}/ambulance-webapi/cmd/ambulance-api-service/main.go`, or we could use the value of the variable `routes` from the file `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl/routers.go`. However, in the case of modifying the specification, when regenerating the skeleton, we would either overwrite the changed files or have to manually overwrite the changes into existing files. To avoid this, we will create our own templates for code generation.

In the command line in the `${WAC_ROOT}/ambulance-webapi` directory, execute the command:

```ps
docker run --rm -ti -v ${PWD}:/local openapitools/openapi-generator-cli author template --generator-name go-gin-server --output /local/scripts/templates
```

This command will create copies of internal generator templates - [mustache][mustache] files - in the directory `${WAC_ROOT}/ambulance-webapi/scripts/templates`. In this directory, delete all files except:

* `controller-api.mustache`
* `routers.mustache`

Deleted files are still available to the generator in its internal template database. To prioritize our templates, we need to modify the file `${WAC_ROOT}/ambulance-webapi/scripts/generator-cfg.yaml` and add the following option:

```yaml
generatorName: go-gin-server
templateDir: /local/scripts/templates @_add_@
...
```

4. The file `${WAC_ROOT}/ambulance-webapi/scripts/templates/controller-api.mustache` serves as a template for generating code for individual controllers - in practice, it is one file or one class for each tag in the [OpenAPI specification][openapi-spec]. Delete the content of this file and insert the following text:

```mustache
{{>partial_header}}
package {{packageName}}

{{#operations}}
import (
  "net/http"

  "github.com/gin-gonic/gin"
)

type {{classname}} interface { @_important_@

  // internal registration of api routes
  addRoutes(routerGroup *gin.RouterGroup)

  {{#operation}}
    // {{nickname}} - {{{summary}}}{{#isDeprecated}}
  // Deprecated{{/isDeprecated}}
  {{nickname}}(ctx *gin.Context)

  {{/operation}}
}

{{/operations}}
```

In this template, we define an interface that will represent the respective part - tag - of our specification, and in it, we declare methods corresponding to individual operations from our specification.

Next, in the same file, insert the template for the implementation of this interface. The implementation is not complete; methods for individual operations are missing and are expected to be implemented outside the generated code:

```mustache
...
{{#operations}}
  ...
type {{classname}} interface {
  ...
}

// partial implementation of {{classname}} - all functions must be implemented in add on files    @_add_@
type impl{{classname}} struct {    @_add_@
@_add_@
}    @_add_@
@_add_@
func new{{classname}}() {{classname}} {    @_add_@
  return &impl{{classname}}{}    @_add_@
}    @_add_@
@_add_@
func (this *impl{{classname}}) addRoutes(routerGroup *gin.RouterGroup) {    @_add_@
  {{#operation}}    @_add_@
  routerGroup.Handle( http.Method{{httpMethod}}, "{{{path}}}", this.{{nickname}})     @_add_@
  {{/operation}}    @_add_@
}    @_add_@

{{#operations}}
```

Finally, insert the code into the file `${WAC_ROOT}/ambulance-webapi/scripts/templates/controller-api.mustache`, which will generate the (commented) example implementation code for individual operations:

```mustache
...
func (this *impl{{classname}}) addRoutes(routerGroup *gin.RouterGroup) {
  ...
}

// Copy following section to separate file, uncomment, and implement accordingly    @_add_@
{{#operation}}    @_add_@
// // {{nickname}} - {{{summary}}}{{#isDeprecated}}    @_add_@
// // Deprecated{{/isDeprecated}}    @_add_@
// func (this *impl{{classname}}) {{nickname}}(ctx *gin.Context) {    @_add_@
//  	ctx.AbortWithStatus(http.StatusNotImplemented)    @_add_@
// }    @_add_@
//    @_add_@
{{/operation}}    @_add_@
```

5. The file `${WAC_ROOT}/ambulance-webapi/scripts/templates/routers.mustache` integrates the individual controllers generated by the previous template. Delete the original content of this file and replace it with the following code:

```mustache
{{>partial_header}}
package {{packageName}}

import (
    "github.com/gin-gonic/gin"
)

func AddRoutes(engine *gin.Engine) {
  group := engine.Group("{{{basePathWithoutHost}}}")
  {{#apiInfo}}{{#apis}}
  {
    api := new{{classname}}()
    api.addRoutes(group)
  }
  {{/apis}}{{/apiInfo}}
}
```

6. Save the files, and in the directory `${WAC_ROOT}/ambulance-webapi`, execute the command:

```ps
./scripts/run.ps1 openapi
```

After executing it, the content of the files in the directory `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl/` will be restored. However, the code is not compilable and reports errors referring to missing method implementations in the classes `implAmbulanceConditionsAPI` and `implAmbulanceWaitingListAPI`.

Create a file `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl/impl_ambulance_conditions.go` and insert the following code:

```go
package ambulance_wl

import (
  "net/http"

  "github.com/gin-gonic/gin"
)

// Following code is copy of generated and commented out code from api_ambulance_confitions.go
func (this *implAmbulanceConditionsAPI) GetConditions(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}
```

Create a file `${WAC_ROOT}/ambulance-webapi/internal/ambulance_wl/impl_ambulance_waiting_list.go` and insert the following code:
  
```go
package ambulance_wl

import (
  "net/http"

  "github.com/gin-gonic/gin"
)

// Following code is copy of generated and commented out code from api_ambulance_confitions.go

// CreateWaitingListEntry - Saves new entry into waiting list
func (this *implAmbulanceWaitingListAPI) CreateWaitingListEntry(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}

// DeleteWaitingListEntry - Deletes specific entry
func (this *implAmbulanceWaitingListAPI) DeleteWaitingListEntry(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}

// GetWaitingListEntries - Provides the ambulance waiting list
func (this *implAmbulanceWaitingListAPI) GetWaitingListEntries(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}

// GetWaitingListEntry - Provides details about waiting list entry
func (this *implAmbulanceWaitingListAPI) GetWaitingListEntry(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}

// UpdateWaitingListEntry - Updates specific entry
func (this *implAmbulanceWaitingListAPI) UpdateWaitingListEntry(ctx *gin.Context) {
  ctx.AbortWithStatus(http.StatusNotImplemented)
}
```

7. Modify the content of the file `${WAC_ROOT}/ambulance-webapi/cmd/ambulance-api-service/main.go`:

```go
package main

import (
    ...
  "github.com/<github_id>/ambulance-webapi/internal/ambulance_wl" @_add_@
)

func main() {
  ...
  // request routings
  ambulance_wl.AddRoutes(engine) @_add_@
  engine.GET("/openapi", api.HandleOpenApi)
  engine.Run(":" + port)
}
```

8. In the directory `${WAC_ROOT}/ambulance-webapi`, execute the command:

```ps
go run cmd/ambulance-api-service/main.go
```

and then in a second terminal, execute the command:

```ps
curl -v http://localhost:8080/api/waiting-list/bobulova/condition
```

The result should be similar to this:

```text
*   Trying 127.0.0.1:8080...
* Connected to localhost (127.0.0.1) port 8080 (#0)
> GET /api/waiting-list/bobulova/condition HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.74.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 501 Not Implemented   @_implemented_@
< Date: Fri, 11 Aug 2023 15:26:48 GMT
< Content-Length: 0
< 
* Connection #0 to host localhost left intact
```

Our server currently returns only the error message `501 Not Implemented`, but that is okay because we have created only the skeleton of the server, which is not yet implemented. In the following steps, we will focus on implementing the server. However, we can easily supplement the specification and regenerate the server skeleton without rewriting existing code. Moreover, the code will not be compilable until we have implemented all operations of our API.

>info:> The templates could be further developed, for example, by providing parameters as input arguments to the methods we need to implement, reducing repetitive code blocks in individual methods. However, for clarity and easier understanding of the next steps, we opted for a simpler but functional implementation of the templates. Various (including more advanced) code generation techniques can be found in the [openapi-generator-cli repository](https://github.com/OpenAPITools/openapi-generator/tree/v7.0.0-beta/modules/openapi-generator/src/main/resources).

9. Archive the changes in the Git repository. In the `${WAC_ROOT}/ambulance-webapi` directory, execute the commands:

```ps
git add .
git commit -m "Kostra servera"
git push
```
